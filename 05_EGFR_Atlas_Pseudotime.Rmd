---
title: "EGFR Atlas Pseudotime Analysis"
author: "Erise Pérez Pascual"
date: "2025-12-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning = FALSE, message = FALSE, cache=TRUE}
# Carga de los paquetes estándar
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)

# Carga y descarga de ProjecTILs
install.packages("BiocManager")

if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

BiocManager::install(c("BiocNeighbors", "BiocParallel", "UCell"))

Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = "true")
options(timeout = 3000)

if (!requireNamespace("renv")) install.packages("renv")
library(renv)
#renv::restore()

remotes::install_github("carmonalab/STACAS")
remotes::install_github("carmonalab/ProjecTILs")

library(ProjecTILs)

# Carga de monocle
BiocManager::install("monocle")
library(monocle)
```

# Importación de los datos

Se carga el atlas de LUAD con mutación *driver* en EGFR, producto de este Trabajo Final. Se trata de un objeto Seurat con información de 75513 genes para 20326 células.

```{r}
# Carga del atlas de EGFR
egfr_atlas <- readRDS("egfr_atlas.rds")
```

# Análisis del estado de las células T

Para analizar el estado de las células T que se usarán para hacer el análisis de trayectoria se utiliza el paquete `ProjecTILs`. Primero, se extraen las células T del conjunto de datos total. El mapa de referencia se descargará desde figshare (https://doi.org/10.6084/m9.figshare.23608308) como un archivo rds. Se trata de un atlas de referencia de células T de tumoresinfiltrados con CD8+ de humanos.

```{r}
# Extracción de células T
tcells <- subset(egfr_atlas, subset = Cell_Cluster_level1 == "T")

# Carga del mapa de referencia
ref <- readRDS("CD8T_human_ref_v1.rds")
```

## Proyección de las células query en el mapa de referencia

Las células *query* son las células T extraídas del atlas de LUAD con mutaciones *driver* en EGFR de este Trabajo Final. Estas se proyectan sobre el mapa de referencia utilizando la función `make.projection()` para luego predecir los estados de las células. Esta función hace un prefiltro de las células T utilizando el paquete `scGate` para purificar una población celular de interés (en este caso las células T). Finalmente, los datos de *query* se cometen a corrección del efecto lote y se proyectan a los espacios de PCA y UMAP de referencia. Este proceso ha identificado 1594 células diana puras (un 18.33% del total), por lo que ha eliminado 7103 células de 8697. Este prefiltraje se puede evitar mediante el argumento `filter.cells=FALSE`. La proyección se puede observar mediante la función `plot.projection()`. A continuación, se predicen los estados celulares y se representa gráficamente la composición con la función `plot.statepred.composition()`. El estado celular más abundante en los datos del atlas son las `CD8.CM` (43.91%) seguidas de las CD8.EM (24.65%), y las menos abundantes son las `CD8.TPEX` (0.38%). El resto de tipos se encuentran entre 6-9.5%. Además, se puede establecer un gráfico tipo radar con la función `plot.states.radar()` que permite comparar los niveles de expresión génica entre los diferentes estados celulares. Las firmas de expresión génica vienen determinadas por el propio paquete de `ProjecTILs` y permiten predecir el estado celular de las células T CD8+ en estudio.

```{r}
# Se hace la proyección
query.projected <- make.projection(tcells, ref=ref)

# Visualización de la proyección
proj1 <- plot.projection(ref, query.projected) + labs(title="Proyección de los datos de entrada en el mapa de referencia de ProjecTILs") + theme_bw()

# Composición predicha
query.projected <- cellstate.predict(ref=ref, query = query.projected)
sort(prop.table(table(query.projected$functional.cluster)), decreasing = T)
proj2 <- plot.statepred.composition(ref, query.projected,metric = "Percent") + labs(title="Porcentajes de la composición de células T predichas para los datos de entrada") + theme_bw()

# Representación de radar
radar <- plot.states.radar(ref, query=query.projected) + theme_bw()

((proj1 + proj2)/radar) + plot_annotation(title="Proyección de las células del atlas en el mapa de referencia y análisis de estado celular")

ggsave("projTILs.png", get_last_plot(), height=15, width=15)
```

```{r}
saveRDS(query.projected, "query_projected.rds")
```


## Selección de las células T CD8+ para el análisis de trayectoria

Las células predichas previamente como células T CD8+ se seleccionan y se filtran del atlas completo de datos.

```{r}
# Selección de células T CD8+ de la predicción
tcells_projecTIL <- query.projected[, colnames(query.projected)]
tcells_projecTIL$functional.cluster <- query.projected$functional.cluster

# Clúster funcional como identidad
Idents(tcells_projecTIL) <- "functional.cluster"

# Selección de las identidades
tcells_cd8 <- subset(tcells_projecTIL, idents = c("CD8.CM", "CD8.EM", "CD8.MAIT", "CD8.NaiveLike", "CD8.TEMRA", "CD8.TEX", "CD8.TPEX"))
```

## Preprocesado del nuevo subconjunto de datos CD8

El nuevo subconjunto de datos se preproceso siguiendo la metodología estándar: escalado de datos, PCA, UMAP, y agrupamiento por clústeres con una resolución del 0.5.

```{r}
all.genes <- rownames(tcells_cd8)
tcells_cd8 <- ScaleData(tcells_cd8, features = all.genes)
tcells_cd8 <- RunPCA(tcells_cd8, features = VariableFeatures(object = tcells_cd8))
tcells_cd8 <- RunUMAP(tcells_cd8, reduction = "pca", dims=1:20, return.model=TRUE)
tcells_cd8 <- FindNeighbors(tcells_cd8, reduction = "pca", dims=1:20)
tcells_cd8 <- FindClusters(tcells_cd8, resolution = 0.5)

DimPlot(tcells_cd8, reduction = "umap", group.by=c("functional.cluster"), label = T, label.size = 3) + labs(title="Distribución celular según el estado celular para las células T CD8") + theme_bw()

ggsave("dimplot_t_cd8.png", get_last_plot(), height=5, width=8)
```

```{r}
#saveRDS(tcells_cd8, "tcells_cd8.rds")
tcells_cd8 <- readRDS("tcells_cd8.rds")
```

# Análisis de trayectoria de las células T CD8+

Primero, se convierte el objeto Seurat en un objeto utilizable por `monocle` con la función `as.CellDataSet()`, y se calcula el tamaño de los factores con la función `estimateSizeFactors()`.

```{r}
# Transformación del objeto Seurat a un objetoCellDataSet
T_monocle <- as.CellDataSet(tcells_cd8, assay="RNA")

# Estimación del tamaño de los factores
T_monocle <- estimateSizeFactors(T_monocle)
```

Se puede observar que el metadata de las células y genes, y la matriz de contajes del objeto Seurat se han conservado en este nuevo objeto, así como la información de los clústeres y las reducciones dimensionales

```{r}
# Metadata de las células
pData(T_monocle)

# Metadata de genes
fData(T_monocle)
rownames(fData(T_monocle))[1:10]
fData(T_monocle)$gene_short_name <- rownames(fData(T_monocle))

# Contajes
exprs(T_monocle)
```

A continuación, se asigna una única partición para todas las células, se asignó la información de los clústeres y se guardó la estructura UMAP. Con esto, se puede añadir la información de los clústeres. Finalmente, se guarda la estructura de UMAP.

```{r}
# Asignación de particiones
recreate.partition <- c(rep(1, length(rownames(T_monocle@phenoData))))
names(recreate.partition) <- rownames(T_monocle@phenoData)
recreate.partition <- as.factor(recreate.partition)
T_monocle@phenoData$UMAP_partitions <- recreate.partition

# Adición de la información de los clústeres
T_monocle@phenoData$UMAP_partitions <- tcells_cd8$functional.cluster

# Estructura UMAP
T_monocle@reducedDimS <- tcells_cd8[["umap"]]@cell.embeddings
```

A continuación, se estudia la trayectoria de las células. Para eso, se reducen las dimensiones a dos con la función `reduceDimension()`, el argumento `max_components = 2`, y utilizando el método de reducción UMAP; para poder ordenar las células con la función `orderCells()`. Estas dos funciones permiten el aprendizaje del modelo de trayectoria de las células en los datos de células T CD8. Previo a estos pasos de aprendizaje del modelo de trayectoria se detectan los genes diferenciales del objeto con el que se está trabajando, utilizando para ello el cálculo de la varianza y la función `detectGenes()`. A continuación, se realiza un análisis diferencial de la expresión de los genes más variables en función de la variable que contiene la información sobre los grupos que se quieren clasificar en el pseudotiempo. Este análisis diferencial se realiza con la función `differentialGeneTest()`, seleccionando los genes más variables y el argumento con la variable con los grupos `fullModelFormulaStr = "~UMAP_partitions"`. De esta manera, se encuentran los genes que están diferencialmente expresados en función del estado celular de las células T CD8+. Estos genes se ordenan y se asignan al objeto para trabajar con ellos el resto del análisis con la funci´pn `setOrderingFilter()`. Para representar los genes de ordenación con `plot_ordering_genes()` se deben estimar primero las dispersiones con la función `estimateDispersions()`.

```{r}
# Filtraje de genes altamente variables según su varianza
T_monocle <- detectGenes(T_monocle, min_expr = 0.1)
variable_genes <- apply(exprs(T_monocle), 1, var)
top_variable_genes <- order(variable_genes, decreasing = T)[1:10000]

# Cálculo de los genes diferencialmente expresados según las particiones UMAP o el estado funcional de las células T CD8+
diff_genes <- differentialGeneTest(T_monocle[top_variable_genes,], fullModelFormulaStr = "~UMAP_partitions")

# Ordención y asignación de los genes diferenciales al objeto de trabajo
ordering_genes <- row.names(subset(diff_genes, qval < 0.01))
T_monocle <- setOrderingFilter(T_monocle, ordering_genes)

# Cálculo de estimación de dispersiones y representación de los genes diferenciales
T_monocle <- estimateDispersions(T_monocle)
plot_ordering_genes(T_monocle)

# Reducción de la dimensionalidad de los datos
T_monocle <- reduceDimension(T_monocle, max_components=2, method = "UMAP")

# Ordenación de las células en la trayectoria
T_monocle <- orderCells(T_monocle)
```

```{r}
#saveRDS(T_monocle, "T_monocle.rds")
T_monocle <- readRDS("T_monocle.rds")
```

## Visualización del análisis de trayectorias

La función propia del paquete `monocle` para la visualización de las trayectorias celulares es `plot_cell_trajectory()`. El gráfico toma una estructura ramificada que indica el momento en el que se genera una ramificación que conlleva a la generación de diferentes tipos celulares o, en este caso, la diferenciación de los estados de las células T CD8+. Estas representaciones se pueden colorear según el estado identificado en el proceso del análisis de trayectoria (los cuales se clasifican según el pseudotiempo), el pseudotiempo o las particiones de UMAP que indican el clúster funcional. En este caso, el mapa muestras dos puntos de ramificación que dan lugar a los cambios de estado celular, según el pseudotiempo.

```{r}
colnames(pData(T_monocle))[colnames(pData(T_monocle)) == "sample_name"] <- "original_sample_name"
# Mapa de trayectorias
traj1 <- plot_cell_trajectory(T_monocle, color_by="State") + theme_bw() + labs(title="Mapa de trayectorias celulares según el estado de la trayectoria, el pseudotiempo o el estado celular")
traj2 <- plot_cell_trajectory(T_monocle, color_by="Pseudotime") + theme_bw()
traj3 <- plot_cell_trajectory(T_monocle, color_by="functional.cluster") + theme_bw()
```

Si bien, el mapa de trayectorias celulares no parece mostrar un cambio de estados claro entre los estados celulares de las células T CD8+, es posible sacar unas conclusiones mediante la observación de los mapas de trayectoria y los datos de proporciones según el estado y el estado celular. Las células en estado `Cd8.NaiveLike` se sitúan con más frecuencia en estados tempranos. Los estados `CD8.TEX` y `CD8.TPEX` son exclusivamente estados celulares tardíos que aparecen únicamente en los estados 3 y 4 correspondientes a los mayores pseudotiempos.

```{r}
prop.table(table(pData(T_monocle)$State, pData(T_monocle)$functional.cluster))
```

Las observaciones anteriores se pueden complementar con representaciones del paquete `Seurat` donde se pueden comparar en el espacio de reducción UMAP los espacios que toman los clúseres celulares y los pseudotiempos. Asimismo, se pueden calcular unos diagramas de cajas según los estadísticos descriptivos necesarios para la descripción de los datos según su distribución en el pseudotiempo.

```{r}
# Visualización
dp <- DimPlot(tcells_cd8, group.by="functional.cluster") + theme_bw() + labs(title="Distribución celular según el estado de las células T CD8+")
fp <- FeaturePlot(tcells_cd8, features="pseudotime") + theme_bw() + labs(title="Distribución celular según el pseudotiempo")

bp <- ggplot(as.data.frame(pData(T_monocle)), aes(Pseudotime, reorder(functional.cluster, Pseudotime, median), fill=functional.cluster)) + geom_boxplot() + theme_bw() + labs(title="Diagrama de cajas según la distribución de cada estado celular")

((traj1+traj2+traj3)/(dp+fp)/bp) + plot_annotation(title="Análisis de la tryectoria en el pseudotiempo")

ggsave("pseudotime_trajectory.png", get_last_plot(), height=14, width=15)
```

# Análisis de trayectoria de células cáncer

Primero, se seleccionan las células del clúster `Cancer` del atlas de LUAD con mutación driver en EGFR. Se obtiene así un conjunto de 1754 células de la población cáncer.

```{r}
egfr_atlas <- readRDS("egfr_atlas.rds")

# Filtraje del atlas en células cáncer
cancer_cells <- subset(egfr_atlas, subset = Cell_Cluster_level1 == "Cancer")
```

A continuación, el objeto Seurat se convierte en un objeto CellDataSet y se procesa igual que antes.

```{r}
# Transformación del objeto Seurat a un objetoCellDataSet
cancer_monocle <- as.CellDataSet(cancer_cells, assay="RNA")

# Estimación del tamaño de los factores
cancer_monocle <- estimateSizeFactors(cancer_monocle)

# Metadata de las células
pData(cancer_monocle)

# Metadata de genes
fData(cancer_monocle)
rownames(fData(cancer_monocle))[1:10]
fData(cancer_monocle)$gene_short_name <- rownames(fData(cancer_monocle))

# Contajes
exprs(cancer_monocle)

# Asignación de particiones
recreate.partition <- c(rep(1, length(rownames(cancer_monocle@phenoData))))
names(recreate.partition) <- rownames(cancer_monocle@phenoData)
recreate.partition <- as.factor(recreate.partition)
cancer_monocle@phenoData$UMAP_partitions <- recreate.partition

# Adición de la información de los clústeres
cancer_monocle@phenoData$UMAP_partitions <- cancer_cells$Cell_Cluster_level2

# Estructura UMAP
cancer_monocle@reducedDimS <- cancer_cells[["umap.ref"]]@cell.embeddings

# Filtraje de genes altamente variables según su varianza
cancer_monocle <- detectGenes(cancer_monocle, min_expr = 0.1)
variable_genes <- apply(exprs(cancer_monocle), 1, var)
top_variable_genes <- order(variable_genes, decreasing = T)[1:10000]

# Cálculo de los genes diferencialmente expresados según las particiones UMAP o el estado funcional de las células T CD8+
diff_genes <- differentialGeneTest(cancer_monocle[top_variable_genes,], fullModelFormulaStr = "~UMAP_partitions")

# Ordención y asignación de los genes diferenciales al objeto de trabajo
ordering_genes <- row.names(subset(diff_genes, qval < 0.01))
cancer_monocle <- setOrderingFilter(cancer_monocle, ordering_genes)

# Cálculo de estimación de dispersiones y representación de los genes diferenciales
cancer_monocle <- estimateDispersions(cancer_monocle)
plot_ordering_genes(cancer_monocle)

# Reducción de la dimensionalidad de los datos
cancer_monocle <- reduceDimension(cancer_monocle, max_components=2, method = "UMAP")

# Ordenación de las células en la trayectoria
cancer_monocle <- orderCells(cancer_monocle)
```

```{r}
#saveRDS(cancer_monocle, "cancer_monocle.rds")
cancer_monocle <- readRDS("cancer_monocle.rds")
```

## Visualización

En este caso, el mapa de trayectoria muestra un único punto de ramificación.

```{r}
colnames(pData(cancer_monocle))[colnames(pData(cancer_monocle)) == "sample_name"] <- "original_sample_name"
# Mapa de trayectorias
traj1 <- plot_cell_trajectory(cancer_monocle, color_by="State") + theme_bw() + labs(title="Mapa de trayectorias celulares según el estado de la trayectoria, el pseudotiempo o el estado celular")
traj2 <- plot_cell_trajectory(cancer_monocle, color_by="Pseudotime") + theme_bw()
traj3 <- plot_cell_trajectory(cancer_monocle, color_by="Cell_Cluster_level2") + theme_bw()

# Visualización
dp <- DimPlot(cancer_cells, group.by="Cell_Cluster_level2") + theme_bw() + labs(title="Distribución celular según el estado de las células cáncer")

cancer_cells@meta.data$pseudotime <- pData(cancer_monocle)$Pseudotime
fp <- FeaturePlot(cancer_cells, features="pseudotime") + theme_bw() + labs(title="Distribución celular según el pseudotiempo")

bp <- ggplot(as.data.frame(pData(cancer_monocle)), aes(Pseudotime, reorder(Cell_Cluster_level2, Pseudotime, median), fill=Cell_Cluster_level2)) + geom_boxplot() + theme_bw() + labs(title="Diagrama de cajas según la distribución de cada estado celular")

((traj1+traj2+traj3)/(dp+fp)/bp) + plot_annotation(title="Análisis de la tryectoria en el pseudotiempo para células cancerígenas")

ggsave("pseudotime_trajectory_cancer.png", get_last_plot(), height=14, width=15)
```

Cluster 2 Alveolar
Cluster 1 Proliferating Cancer
Cluster 3 Pathological Alveolar

```{r}
prop.table(table(pData(cancer_monocle)$State, pData(cancer_monocle)$Cell_Cluster_level2))
```

