---
title: "EGFR Atlas Pseudotime Analysis"
author: "Erise Pérez Pascual"
date: "2025-12-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning = FALSE, message = FALSE}
# Carga de los paquetes estándar
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)

# Carga y descarga de ProjecTILs
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

BiocManager::install(c("BiocNeighbors", "BiocParallel", "UCell"))

Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = "true")
options(timeout = 3000)

if (!requireNamespace("renv")) install.packages("renv")
library(renv)
#renv::restore()

remotes::install_github("carmonalab/STACAS")
remotes::install_github("carmonalab/ProjecTILs")

library(ProjecTILs)

# Carga de monocle3

install.packages("cli", dependencies=T, version="3.6.5")

BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor', 'HDF5Array',
                       'ggrastr'))

install.packages("devtools")
remotes::install_github("bnprks/BPCells/r")

devtools::install_github("cole-trapnell-lab/monocle3") # Requiere RTools

library(monocle3)
```

# Importación de los datos

Se carga el atlas de LUAD con mutación *driver* en EGFR, producto de este Trabajo Final. Se trata de un objeto Seurat con información de 75513 genes para 20326 células.

```{r}
# Carga del atlas de EGFR
egfr_atlas <- readRDS("egfr_atlas.rds")
```

# Análisis del estado de las células T

Para analizar el estado de las células T que se usarán para hacer el análisis de trayectoria se utiliza el paquete `ProjecTILs`. Primero, se extraen las células T del conjunto de datos total. El mapa de referencia se descargará desde figshare (https://doi.org/10.6084/m9.figshare.23608308) como un archivo rds. Se trata de un atlas de referencia de células T de tumoresinfiltrados con CD8+ de humanos.

```{r}
# Extracción de células T
tcells <- subset(egfr_atlas, subset = Cell_Cluster_level1 == "T")

# Carga del mapa de referencia
ref <- readRDS("CD8T_human_ref_v1.rds")
```

## Proyección de las células query en el mapa de referencia

Las células *query* son las células T extraídas del atlas de LUAD con mutaciones *driver* en EGFR de este Trabajo Final. Estas se proyectan sobre el mapa de referencia utilizando la función `make.projection()` para luego predecir los estados de las células. Esta función hace un prefiltro de las células T utilizando el paquete `scGate` para purificar una población celular de interés (en este caso las células T). Finalmente, los datos de *query* se cometen a corrección del efecto lote y se proyectan a los espacios de PCA y UMAP de referencia. Este proceso ha identificado 1594 células diana puras (un 18.33% del total), por lo que ha eliminado 7103 células de 8697. Este prefiltraje se puede evitar mediante el argumento `filter.cells=FALSE`. La proyección se puede observar mediante la función `plot.projection()`. A continuación, se predicen los estados celulares y se representa gráficamente la composición con la función `plot.statepred.composition()`. El estado celular más abundante en los datos del atlas son las `CD8.CM` (43.91%) seguidas de las CD8.EM (24.65%), y las menos abundantes son las `CD8.TPEX` (0.38%). El resto de tipos se encuentran entre 6-9.5%. Además, se puede establecer un gráfico tipo radar con la función `plot.states.radar()` que permite comparar los niveles de expresión génica entre los diferentes estados celulares. Las firmas de expresión génica vienen determinadas por el propio paquete de `ProjecTILs` y permiten predecir el estado celular de las células T CD8+ en estudio.

```{r}
# Se hace la proyección
query.projected <- make.projection(tcells, ref=ref)

# Visualización de la proyección
proj1 <- plot.projection(ref, query.projected) + labs(title="Proyección de los datos de entrada en el mapa de referencia de ProjecTILs") + theme_bw()

# Composición predicha
query.projected <- cellstate.predict(ref=ref, query = query.projected)
sort(prop.table(table(query.projected$functional.cluster)), decreasing = T)
proj2 <- plot.statepred.composition(ref, query.projected,metric = "Percent") + labs(title="Porcentajes de la composición de células T predichas para los datos de entrada") + theme_bw()

# Representación de radar
radar <- plot.states.radar(ref, query=query.projected) + theme_bw()

((proj1 + proj2)/radar) + plot_annotation(title="Proyección de las células del atlas en el mapa de referencia y análisis de estado celular")

ggsave("projTILs.png", get_last_plot(), height=15, width=15)
```

```{r}
saveRDS(query.projected, "query_projected.rds")
```


## Selección de las células T CD8+ para el análisis de trayectoria

Las células predichas previamente como células T CD8+ se seleccionan y se filtran del atlas completo de datos.

```{r}
# Selección de células T CD8+ de la predicción
tcells_projecTIL <- query.projected[, colnames(query.projected)]
tcells_projecTIL$functional.cluster <- query.projected$functional.cluster

# Clúster funcional como identidad
Idents(tcells_projecTIL) <- "functional.cluster"

# Selección de las identidades
tcells_cd8 <- subset(tcells_projecTIL, idents = c("CD8.CM", "CD8.EM", "CD8.MAIT", "CD8.NaiveLike", "CD8.TEMRA", "CD8.TEX", "CD8.TPEX"))
```

## Preprocesado del nuevo subconjunto de datos CD8

El nuevo subconjunto de datos se preproceso siguiendo la metodología estándar: escalado de datos, PCA, UMAP, y agrupamiento por clústeres con una resolución del 0.5.

```{r}
all.genes <- rownames(tcells_cd8)
tcells_cd8 <- ScaleData(tcells_cd8, features = all.genes)
tcells_cd8 <- RunPCA(tcells_cd8, features = VariableFeatures(object = tcells_cd8))
tcells_cd8 <- RunUMAP(tcells_cd8, reduction = "pca", dims=1:20)
tcells_cd8 <- FindNeighbors(tcells_cd8, reduction = "pca", dims=1:20)
tcells_cd8 <- FindClusters(tcells_cd8, resolution = 0.5)

DimPlot(tcells_cd8, reduction = "umap", group.by=c("functional.cluster"), label = T, label.size = 3) + labs(title="Distribución celular según el estado celular para las células T CD8") + theme_bw()

ggsave("dimplot_t_cd8.png", get_last_plot(), height=5, width=8)
```

```{r}
#saveRDS(tcells_cd8, "tcells_cd8.rds")
readRDS("tcells_cd8.rds")
```



##Trajectory analysis of CD8+ T cells
#Transform Seurat object into cell_data_set object
T_monocle <- as.cell_data_set(tcells_projecTilCD8, assay = "RNA")
T_monocle <- estimate_size_factors(T_monocle)

#Get cell metadata
colData(T_monocle)

#Get gene metadata
fData(T_monocle)
rownames(fData(T_monocle))[1:10]
fData(T_monocle)$gene_short_name <- rownames(fData(T_monocle))

#Get counts
counts(T_monocle)

#Assign partitions
recreate.partiion <- c(rep(1,length(T_monocle@colData@rownames)))
names(recreate.partiion) <- T_monocle@colData@rownames
recreate.partiion <- as.factor(recreate.partiion)
T_monocle@clusters$UMAP$partitions <- recreate.partiion

#Assign cluster info
list_cluster <- tcells_projecTilCD8$functional.cluster
T_monocle@clusters$UMAP$clusters <- list_cluster

#Save umap structure
T_monocle@int_colData@listData$reducedDims$UMAP <- tcells_projecTilCD8@reductions$umap@cell.embeddings


#Learn trajectory graph
T_monocle <- learn_graph(T_monocle, use_partition = F)
plot_cells(T_monocle, color_cells_by = "functional.cluster", label_groups_by_cluster = F, label_branch_points = F,
           label_roots = F, label_leaves = F, group_label_size = 0) + theme_bw()


#Oder cells in pseudotime
get_earliest_principal_node <- function(T_monocle, time_bin="CD8_NaiveLike"){
  cell_ids <- which(colData(T_monocle)[, "functional.cluster"] == time_bin)
  
  closest_vertex <-
    T_monocle@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(T_monocle), ])
  root_pr_nodes <-
    igraph::V(principal_graph(T_monocle)[["UMAP"]])$name[as.numeric(names
                                                                     (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}


#Visualization
plot_cells(T_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = F, label_branch_points = F,
           label_roots = F, label_leaves = F, group_label_size = 0) + theme_bw()

pseudotime(T_monocle) # cells ordered by pseudotime
T_monocle$monocle3_pseudotime <- pseudotime(T_monocle)
data_pseudo <- as.data.frame(colData(T_monocle))
ggplot(data_pseudo, aes(monocle3_pseudotime, reorder(functional.cluster, monocle3_pseudotime, median), fill = functional.cluster)) + geom_boxplot()


#Find genes with changing expression in pseudotime
genes_T <- graph_test(T_monocle, neighbor_graph = "principal_graph", cores = 4)
#top genes
topgenes <- genes_T %>%
  arrange(q_value) %>%
  filter(status == "OK") 

plot_genes_in_pseudotime(T_monocle[rowData(T_monocle)$gene_short_name %in% 
                       c("Ccr7","Ttc19","Cd69","Klrb1","Id2","Gzma","Gzmb",...),],
                       color_cells_by="pseudotime",ncol=8, min_expr=0.5, cell_size=1) 


#Visualize pseudotime in seurat
tcells_projecTilCD8$pseudotime <- pseudotime(T_monocle)
FeaturePlot(tcells_projecTilCD8, features = "pseudotime", label = F) + theme_bw()
FeaturePlot(tcells_projecTilCD8, features = c("Ccr7","Ttc19","Cd69","Klrb1","Id2","Gzma","Gzmb",...), ncol=4) 


########################################