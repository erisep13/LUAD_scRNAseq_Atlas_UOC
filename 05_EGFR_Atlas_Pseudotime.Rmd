---
title: "EGFR Atlas Pseudotime Analysis"
author: "Erise Pérez Pascual"
date: "2025-12-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning = FALSE, message = FALSE, cache=TRUE}
# Carga de los paquetes estándar
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)

# Carga y descarga de ProjecTILs
install.packages("BiocManager")

if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

BiocManager::install(c("BiocNeighbors", "BiocParallel", "UCell"))

Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS = "true")
options(timeout = 3000)

if (!requireNamespace("renv")) install.packages("renv")
library(renv)
#renv::restore()

remotes::install_github("carmonalab/STACAS")
remotes::install_github("carmonalab/ProjecTILs")

library(ProjecTILs)

# Carga de monocle3

install.packages("cli", dependencies=T, version="3.6.5")

BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor', 'HDF5Array',
                       'ggrastr'))

install.packages("devtools")
remotes::install_github("bnprks/BPCells/r")
install.packages("BPCells")
install.packages("grr_0.9.1.tar.gz")
library(grr)

devtools::install_github("cole-trapnell-lab/monocle3") # Requiere RTools
BiocManager::install("monocle")
library(monocle3)
library(monocle)
```

# Importación de los datos

Se carga el atlas de LUAD con mutación *driver* en EGFR, producto de este Trabajo Final. Se trata de un objeto Seurat con información de 75513 genes para 20326 células.

```{r}
# Carga del atlas de EGFR
egfr_atlas <- readRDS("egfr_atlas.rds")
```

# Análisis del estado de las células T

Para analizar el estado de las células T que se usarán para hacer el análisis de trayectoria se utiliza el paquete `ProjecTILs`. Primero, se extraen las células T del conjunto de datos total. El mapa de referencia se descargará desde figshare (https://doi.org/10.6084/m9.figshare.23608308) como un archivo rds. Se trata de un atlas de referencia de células T de tumoresinfiltrados con CD8+ de humanos.

```{r}
# Extracción de células T
tcells <- subset(egfr_atlas, subset = Cell_Cluster_level1 == "T")

# Carga del mapa de referencia
ref <- readRDS("CD8T_human_ref_v1.rds")
```

## Proyección de las células query en el mapa de referencia

Las células *query* son las células T extraídas del atlas de LUAD con mutaciones *driver* en EGFR de este Trabajo Final. Estas se proyectan sobre el mapa de referencia utilizando la función `make.projection()` para luego predecir los estados de las células. Esta función hace un prefiltro de las células T utilizando el paquete `scGate` para purificar una población celular de interés (en este caso las células T). Finalmente, los datos de *query* se cometen a corrección del efecto lote y se proyectan a los espacios de PCA y UMAP de referencia. Este proceso ha identificado 1594 células diana puras (un 18.33% del total), por lo que ha eliminado 7103 células de 8697. Este prefiltraje se puede evitar mediante el argumento `filter.cells=FALSE`. La proyección se puede observar mediante la función `plot.projection()`. A continuación, se predicen los estados celulares y se representa gráficamente la composición con la función `plot.statepred.composition()`. El estado celular más abundante en los datos del atlas son las `CD8.CM` (43.91%) seguidas de las CD8.EM (24.65%), y las menos abundantes son las `CD8.TPEX` (0.38%). El resto de tipos se encuentran entre 6-9.5%. Además, se puede establecer un gráfico tipo radar con la función `plot.states.radar()` que permite comparar los niveles de expresión génica entre los diferentes estados celulares. Las firmas de expresión génica vienen determinadas por el propio paquete de `ProjecTILs` y permiten predecir el estado celular de las células T CD8+ en estudio.

```{r}
# Se hace la proyección
query.projected <- make.projection(tcells, ref=ref)

# Visualización de la proyección
proj1 <- plot.projection(ref, query.projected) + labs(title="Proyección de los datos de entrada en el mapa de referencia de ProjecTILs") + theme_bw()

# Composición predicha
query.projected <- cellstate.predict(ref=ref, query = query.projected)
sort(prop.table(table(query.projected$functional.cluster)), decreasing = T)
proj2 <- plot.statepred.composition(ref, query.projected,metric = "Percent") + labs(title="Porcentajes de la composición de células T predichas para los datos de entrada") + theme_bw()

# Representación de radar
radar <- plot.states.radar(ref, query=query.projected) + theme_bw()

((proj1 + proj2)/radar) + plot_annotation(title="Proyección de las células del atlas en el mapa de referencia y análisis de estado celular")

ggsave("projTILs.png", get_last_plot(), height=15, width=15)
```

```{r}
saveRDS(query.projected, "query_projected.rds")
```


## Selección de las células T CD8+ para el análisis de trayectoria

Las células predichas previamente como células T CD8+ se seleccionan y se filtran del atlas completo de datos.

```{r}
# Selección de células T CD8+ de la predicción
tcells_projecTIL <- query.projected[, colnames(query.projected)]
tcells_projecTIL$functional.cluster <- query.projected$functional.cluster

# Clúster funcional como identidad
Idents(tcells_projecTIL) <- "functional.cluster"

# Selección de las identidades
tcells_cd8 <- subset(tcells_projecTIL, idents = c("CD8.CM", "CD8.EM", "CD8.MAIT", "CD8.NaiveLike", "CD8.TEMRA", "CD8.TEX", "CD8.TPEX"))
```

## Preprocesado del nuevo subconjunto de datos CD8

El nuevo subconjunto de datos se preproceso siguiendo la metodología estándar: escalado de datos, PCA, UMAP, y agrupamiento por clústeres con una resolución del 0.5.

```{r}
all.genes <- rownames(tcells_cd8)
tcells_cd8 <- ScaleData(tcells_cd8, features = all.genes)
tcells_cd8 <- RunPCA(tcells_cd8, features = VariableFeatures(object = tcells_cd8))
tcells_cd8 <- RunUMAP(tcells_cd8, reduction = "pca", dims=1:20, return.model=TRUE)
tcells_cd8 <- FindNeighbors(tcells_cd8, reduction = "pca", dims=1:20)
tcells_cd8 <- FindClusters(tcells_cd8, resolution = 0.5)

DimPlot(tcells_cd8, reduction = "umap", group.by=c("functional.cluster"), label = T, label.size = 3) + labs(title="Distribución celular según el estado celular para las células T CD8") + theme_bw()

ggsave("dimplot_t_cd8.png", get_last_plot(), height=5, width=8)
```

```{r}
#saveRDS(tcells_cd8, "tcells_cd8.rds")
tcells_cd8 <- readRDS("tcells_cd8.rds")
```

# Análisis de trayectoria de las células T CD8+

Primero, se convierte el objeto Seurat en un objeto utilizable por `monocle` con la función `as.CellDataSet()`, y se calcula el tamaño de los factores con la función `estimateSizeFactors()`.

```{r}
# Transformación del objeto Seurat a un objeto cell_data_set
T_monocle <- as.CellDataSet(tcells_cd8, assay="RNA")

# Estimación del tamaño de los factores
T_monocle <- estimateSizeFactors(T_monocle)
```

Se puede observar que el metadata de las células y genes, y la matriz de contajes del objeto Seurat se han conservado en este nuevo objeto, así como la información de los clústeres y las reducciones dimensionales

```{r}
# Metadata de las células
pData(T_monocle)

# Metadata de genes
fData(T_monocle)
rownames(fData(T_monocle))[1:10]
fData(T_monocle)$gene_short_name <- rownames(fData(T_monocle))

# Contajes
exprs(T_monocle)
```

A continuación, se asignó una única partición para todas las células, se asignó la información de los clústeres y se guardó la estructura UMAP. Con esto, se puede añadir la información de los clústeres. Finalmente, se guarda la estructura de UMAP.

```{r}
# Asignación de particiones
recreate.partition <- c(rep(1, length(rownames(T_monocle@phenoData))))
names(recreate.partition) <- rownames(T_monocle@phenoData)
recreate.partition <- as.factor(recreate.partition)
T_monocle@phenoData$UMAP_partitions <- recreate.partition

# Adición de la información de los clústeres
T_monocle@phenoData$UMAP_partitions <- tcells_cd8$functional.cluster

# Estructura UMAP
T_monocle@reducedDimS <- tcells_cd8[["umap"]]@cell.embeddings
```

A continuación, se estudia la trayectoria de las células. Para eso, se reducen las dimensiones a dos con la función `reduceDimension()`, el argumento `max_components = 2`, y utilizando el método de reducción UMAP; para poder ordenar las células con la función `orderCells()`. En la ordenación de las células se determina como estado inicial las células `CD8.NaiveLike` con el argumento `root_state = "CD8.NaiveLike"`. Estas dos funciones permiten el aprendizaje del modelo de trayectoria de las células en los datos de células T CD8.

```{r}
# Elección de genes diferenciales, según las particiones de UMAP según el cluster funcional
T_monocle <- detectGenes(T_monocle, min_expr = 0.1)
variable_genes <- apply(exprs(T_monocle), 1, var)
top_variable_genes <- order(variable_genes, decreasing = T)[1:10000]
diff_genes <- differentialGeneTest(T_monocle[top_variable_genes,], fullModelFormulaStr = "~UMAP_partitions")
ordering_genes <- row.names(subset(diff_genes, qval < 0.01))
T_monocle <- setOrderingFilter(T_monocle, ordering_genes)
T_monocle <- estimateDispersions(T_monocle)
plot_ordering_genes(T_monocle)

# Reducción de la dimensionalidad de los datos
T_monocle <- reduceDimension(T_monocle, max_components=2, method = "UMAP")

# Ordenación de las células en la trayectoria
T_monocle <- orderCells(T_monocle)
```

```{r}
#saveRDS(T_monocle, "T_monocle.rds")
T_monocle <- readRDS("T_monocle.rds")
```


```{r}
colnames(pData(T_monocle))[colnames(pData(T_monocle)) == "sample_name"] <- "original_sample_name"
plot_cell_trajectory(T_monocle, color_by="State") + theme_bw()
plot_cell_trajectory(T_monocle, color_by="Pseudotime") + theme_bw()
plot_cell_trajectory(T_monocle, color_by="UMAP_partitions") + theme_bw()
plot_cell_clusters(T_monocle, color_by="Pseudotime")
```

```{r}
#Visualization
plot_cell_trajectory(T_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T, label_branch_points = F,
           label_roots = F, label_leaves = F, group_label_size = 3) + theme_bw()

pseudotime(T_monocle) # cells ordered by pseudotime
T_monocle$monocle3_pseudotime <- pseudotime(T_monocle)
data_pseudo <- as.data.frame(colData(T_monocle))
ggplot(data_pseudo, aes(monocle3_pseudotime, reorder(functional.cluster, monocle3_pseudotime, median), fill = functional.cluster)) + geom_boxplot()
```



#Find genes with changing expression in pseudotime
genes_T <- graph_test(T_monocle, neighbor_graph = "principal_graph", cores = 4)
#top genes
topgenes <- genes_T %>%
  arrange(q_value) %>%
  filter(status == "OK") 

plot_genes_in_pseudotime(T_monocle[rowData(T_monocle)$gene_short_name %in% 
                       c("Ccr7","Ttc19","Cd69","Klrb1","Id2","Gzma","Gzmb",...),],
                       color_cells_by="pseudotime",ncol=8, min_expr=0.5, cell_size=1) 


#Visualize pseudotime in seurat
tcells_projecTilCD8$pseudotime <- pseudotime(T_monocle)
FeaturePlot(tcells_projecTilCD8, features = "pseudotime", label = F) + theme_bw()
FeaturePlot(tcells_projecTilCD8, features = c("Ccr7","Ttc19","Cd69","Klrb1","Id2","Gzma","Gzmb",...), ncol=4) 


########################################